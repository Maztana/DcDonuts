#include "mixededucationalquiz.h"


/** Constructor
 * @brief MixedEducationalQuiz::MixedEducationalQuiz
 */
MixedEducationalQuiz::MixedEducationalQuiz()
    :EducationalQuiz()
{
    m_isMixed = true;
    m_currentGameType = nullptr;
    m_currentQuestion = nullptr;
}

/** Destructor
 * @brief MixedEducationalQuiz::~MixedEducationalQuiz
 */
MixedEducationalQuiz::~MixedEducationalQuiz()
{
    qDeleteAll(m_listEducationalQuiz);
}

/** Add type Quiz in the mixed mode
 * @brief MixedEducationalQuiz::addGameType
 * @param typeQuiz the new quiz type
 */
void MixedEducationalQuiz::addGameType(EducationalQuiz* typeQuiz)
{
    m_listEducationalQuiz.append(typeQuiz);

    /** connection signaux*/
    connect(typeQuiz, SIGNAL(answerRight(int)), this, SLOT(rightAnswer(int)));
    connect(typeQuiz, SIGNAL(incrementScore(int)), this, SLOT(scoreIncrement(int)));
    connect(typeQuiz, SIGNAL(answerWrong(int)), this, SLOT(wrongAnswer(int)));
    connect(typeQuiz, SIGNAL(decrementScore(int)), this, SLOT(scoreDecrement(int)));
    ////////////////////////////////////////////////////////////////////////////////////////////////////
}

/** Build question with current type game
 * @brief MixedEducationalQuiz::buildQuestion
 * @return the new current question
 */
Question* MixedEducationalQuiz::buildQuestion()
{
    return m_currentGameType->buildQuestion();
}

/** Getter of the proposition of current question of current type game
 * @brief MixedEducationalQuiz::getProposition
 * @return the proposition question
 */
const QString MixedEducationalQuiz::getProposition()const
{
    return m_currentGameType->getProposition();
}

/** Getter of the result of current question of current type game
 * @brief MixedEducationalQuiz::getResult
 * @return the result question
 */
const QString MixedEducationalQuiz::getResult()const
{
    return m_currentGameType->getResult();
}

/** Getter of the text of current question of current type game
 * @brief MixedEducationalQuiz::makeTextQuestion
 * @return the text question
 */
const QString MixedEducationalQuiz::makeTextQuestion(QList<QString> values)const
{
    return m_currentGameType->makeTextQuestion(values);
}

/** Setter of list propositions, autogenerated with the question operand
 * @brief MixedEducationalQuiz::setListPropositions
 */
void MixedEducationalQuiz::setListPropositions()
{
    m_listPropositions = m_currentGameType->getPropositions();
}

/** Setter of list levels selectable
 * @brief MixedEducationalQuiz::setLevelsSelectable
 */
void MixedEducationalQuiz::setLevelsSelectable()
{
    bool isFirst = true;
    for(EducationalQuiz* quiz : m_listEducationalQuiz)
    {
        quiz->initLevelsSelectable();
        if(isFirst)
        {
            m_listLevelsSelectable.append(quiz->getLevelsSelectable());
            isFirst = false;
        }
        else
        {
            for(int levelIndex : m_listLevelsSelectable)
            {
                if(!quiz->getLevelsSelectable().contains(levelIndex))
                {
                    m_listLevelsSelectable.removeAt(m_listLevelsSelectable.indexOf(levelIndex));
                }
            }
        }
    }
    emit levelsSelectableChanged();
}

/** Setter for the number of propositions also level
 * @brief MixedEducationalQuiz::setNumberPropositions
 */
void MixedEducationalQuiz::setNumberPropositions()
{
    if(m_currentGameType != nullptr)
    {
        m_numberPropositions = m_currentGameType->getNumberPropositions();
        emit numberPropositionsChanged();
    }
}

/** Treat response for classic quiz (no flascard)
 * @brief MixedEducationalQuiz::treatmentAnswer
 * @param indexAnswer the index of answer
 */
void MixedEducationalQuiz::treatmentAnswer(const int indexAnswer)
{
    m_currentGameType->treatAnswer(indexAnswer);
}

/** Setter for the level game
 * @brief MixedEducationalQuiz::initLevelGame
 * @param indexLevel the level game index
 */
void MixedEducationalQuiz::initLevelGame(int indexLevel)
{
    delete(m_levelGame);
    Level* level = new Level(indexLevel);

    for(EducationalQuiz* quiz : m_listEducationalQuiz)
    {
        quiz->initLevelGame(level->getIndex());
    }
    m_levelGame = level;
}

/** Launcher of question
 * @brief MixedEducationalQuiz::launchQuestion
 */
void MixedEducationalQuiz::launchQuestion()
{
    m_currentGameType = m_listEducationalQuiz.at(qrand() % (m_listEducationalQuiz.size()));

    m_currentGameType->launchQuestion();
    setListPropositions();
    newQuestion();
}

/** Emit answerRight
 * @brief MixedEducationalQuiz::rightAnswer
 * @param indexAnswer
 */
void MixedEducationalQuiz::rightAnswer(int indexAnswer)
{
    emit answerRight(indexAnswer);
}

/** Emit incrementScore
 * @brief MixedEducationalQuiz::scoreIncrement
 * @param incrementalScore
 */
void MixedEducationalQuiz::scoreIncrement(int incrementalScore)
{

    emit incrementScore(incrementalScore);
}

/** emit answerWrong
 * @brief MixedEducationalQuiz::wrongAnswer
 * @param indexAnswer
 */
void MixedEducationalQuiz::wrongAnswer(int indexAnswer)
{

    emit answerWrong(indexAnswer);
}

/** emit scoreDecrement
 * @brief MixedEducationalQuiz::scoreDecrement
 * @param decrementalScore
 */
void MixedEducationalQuiz::scoreDecrement(int decrementalScore)
{

    emit decrementScore(decrementalScore);
}
